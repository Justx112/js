/* Создайте декоратор spy(func), который должен возвращать обёртку, которая сохраняет все вызовы функции в своём свойстве calls.

Каждый вызов должен сохраняться как массив аргументов.

Например: */

function work(a, b) {
    console.log(a + b); // произвольная функция или метод
}

function spy(func){
    function helpFunction(){
        helpFunction.calls.push(Array.from(arguments))
        return func.apply(this, arguments)
    }
    helpFunction.calls = []

    return helpFunction
}

work = spy(work);

work(1, 2); // 3
work(4, 5); // 9

for (let args of work.calls) {
    console.log('call:' + args.join()); // "call:1,2", "call:4,5"
}

/* Создайте декоратор delay(f, ms), который задерживает каждый вызов f на ms миллисекунд.Например:

function f(x) {
    alert(x);
}

// создаём обёртки
let f1000 = delay(f, 1000);
let f1500 = delay(f, 1500);

f1000("test"); // показывает "test" после 1000 мс
f1500("test"); // показывает "test" после 1500 мс
Другими словами, delay(f, ms) возвращает вариант f с «задержкой на ms мс».

В приведённом выше коде f – функция с одним аргументом, но ваше решение должно передавать все аргументы и контекст this. */

function f(x) {
    console.log(x);
}

function delay(sourceFunc, ms){
    function helpFunction(){
        setTimeout(()=>{sourceFunc.apply(this,arguments)},ms);
    }
    return helpFunction
}

let f1000 = delay(f, 1000);
let f1500 = delay(f, 1500);

f1000("test"); // показывает "test" после 1000 мс
f1500("test"); // показывает "test" после 1500 мс

/* Результатом декоратора debounce(f, ms) должна быть обёртка, которая передаёт вызов f не более одного раза в ms миллисекунд.Другими словами,
когда мы вызываем debounce, это гарантирует, что все остальные вызовы будут игнорироваться в течение ms.

Например:

let f = debounce(alert, 1000);

f(1); // выполняется немедленно
f(2); // проигнорирован

setTimeout(() => f(3), 100); // проигнорирован (прошло только 100 мс)
setTimeout(() => f(4), 1100); // выполняется
setTimeout(() => f(5), 1500); // проигнорирован (прошло только 400 мс от последнего вызова)
На практике debounce полезен для функций, которые получают / обновляют данные, и мы знаем,
 что повторный вызов в течение короткого промежутка времени не даст ничего нового.Так что лучше не тратить на него ресурсы. */

function debounce(sourceFunc, destinationFunc){
    helpFunction.lastCall = 0
    function helpFunction(){
        let currentTime = Date.now()
        let diffrent = currentTime - helpFunction.lastCall
        if (diffrent > destinationFunc){
            helpFunction.lastCall = Date.now()
            return sourceFunc.apply(this, arguments)
        }
    }
    return helpFunction
}

function alert(a){
    console.log(`${a}`)
}

let debouncedFunction = debounce(alert, 1000);

debouncedFunction(1); // выполняется немедленно
debouncedFunction(2); // проигнорирован

setTimeout(() => debouncedFunction(3), 100); // проигнорирован (прошло только 100 мс)
setTimeout(() => debouncedFunction(4), 1100); // выполняется
setTimeout(() => debouncedFunction(5), 1500); // проигнорирован (прошло только 400 мс от последнего вызова)
// Я искрени не понимаю в чем тут проблема, с ноды все работает замечательно,
// в песочнице от learn js вообще не видит значения.


/* 
Создайте «тормозящий» декоратор throttle(f, ms), который возвращает обёртку,
передавая вызов в f не более одного раза в ms миллисекунд.Те вызовы, которые попадают в период «торможения», игнорируются.

Отличие от debounce – если проигнорированный вызов является последним во время «задержки», то он выполняется в конце.

Давайте рассмотрим реальное применение, чтобы лучше понять это требование и выяснить, откуда оно взято.

Например, мы хотим отслеживать движения мыши.

В браузере мы можем объявить функцию, которая будет запускаться при каждом движении указателя и получать его местоположение.
Во время активного использования мыши эта функция запускается очень часто, это может происходить около 100 раз в секунду(каждые 10 мс).

Мы бы хотели обновлять информацию на странице при передвижениях.

…Но функция обновления update() слишком ресурсоёмкая, чтобы делать это при каждом микродвижении.
Да и нет смысла делать обновление чаще, чем один раз в 1000 мс.

Поэтому мы обернём вызов в декоратор: будем использовать throttle(update, 1000) как функцию,
которая будет запускаться при каждом перемещении указателя вместо оригинальной update().Декоратор будет вызываться часто,
но передавать вызов в update() максимум раз в 1000 мс.

Визуально это будет выглядеть вот так:

Для первого движения указателя декорированный вариант сразу передаёт вызов в update.Это важно, т.к.пользователь сразу видит нашу реакцию на его перемещение.
Затем, когда указатель продолжает движение, в течение 1000 мс ничего не происходит.Декорированный вариант игнорирует вызовы.
По истечению 1000 мс происходит ещё один вызов update с последними координатами.
Затем, наконец, указатель где - то останавливается.Декорированный вариант ждёт, пока не истечёт 1000 мс,
и затем вызывает update с последними координатами.В итоге окончательные координаты указателя тоже обработаны.
Пример кода: */

function f(a) {
    console.log(a)
}

function throttle(sourceFunc, delay) {

    let stoped = false
    let savedArgs
    let savedThis

    function wrapper() {

        if (stoped) {
            savedArgs = arguments;
            savedThis = this;
            return;
        }

        sourceFunc.apply(this, arguments);

        stoped = true;

        setTimeout(function () {
            stoped = false;
            if (savedArgs) {
                wrapper.apply(savedThis, savedArgs);
                savedArgs = savedThis = null;
            }
        }, delay);
    }

    return wrapper;
}
// f1000 передаёт вызовы f максимум раз в 1000 мс
let f1000_2 = throttle(f, 1000);

f1000(1); // показывает 1
f1000(2); // (ограничение, 1000 мс ещё нет)
f1000(3); // (ограничение, 1000 мс ещё нет)

// когда 1000 мс истекли ...
// ...выводим 3, промежуточное значение 2 было проигнорировано